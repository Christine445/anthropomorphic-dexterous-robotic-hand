#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>

///////////////////////////////////////////////////////
///////////////////    CONSTANTS    ///////////////////
///////////////////////////////////////////////////////
// in pulselength: SERVOMIN: 120; SERVOMAX: 420 --> maximaler Bereich eines Servos [180,410]



//These values are obtained through calculations and experimental measurements.
const double r_c_x4 = 3/2;
const double r_b_x3 = 13/11;
const double r_a_x2 = 8/7;

const int SERVOMIN = 140;       // this value depends on the adjustment of the servos
const int SERVOMAX = 420;       // this value depends on the adjustment of the servos
const int SCHRITTWEITE = 10;    // setting up the step size of the servos

const int SERVOMIN_1 = 120; //corresponds to the DIP, PIP and MCP joints 
const int SERVOMAX_1 = 420; //corresponds to the DIP, PIP and MCP joints 

const int SERVOMIN_2 = 120; //corresponds to the DIP joint (fingertip) as well as to x_current_2
const int SERVOMAX_2 = 420; //corresponds to the DIP joint (fingertip) as well as to x_current_2

const int SERVOMIN_3 = 180;  //corresponds to the PIP joint as well as to x_current_3
const int SERVOMAX_3 = 310;  //corresponds to the PIP joint as well as to x_current_3

const int SERVOMIN_4 = 270; //corresponds to the MCP joint as well as to x_current_4
const int SERVOMAX_4 = 350; //corresponds to the MCP joint as well as to x_current_4

const int wrist_fe_start = 420;       // movement of the wrist from flexion to extension
const int wrist_ef_start = 140;       // movement of the wrist from extension to flexion
const int wrist_ru_start = 420;       // movement of the wrist from radial to ulnar
const int wrist_ur_start = 120;       // movement of the wrist from ulnar to radial
const int neutral_position = 270; 

// These values were obtained by experiments. These values represents the highest stretched position of the servo motor.
const int x_start_4 = SERVOMAX_4-120*r_c_x4;                     // x_4 corresponts to gamma / MCP joint 270
const int x_start_3 = SERVOMAX_3-110*r_b_x3;                     // x_3 corresponts to beta / PIP joint 280
const int x_start_2 = SERVOMAX_2-70*r_a_x2;                     // x_2 corresponts to alpha / DIP joint 350
const int x_start_1 = SERVOMAX_1;                     // x_1 corresponts to all joint 420


// Put in values in degree for the finger joints:
int delta_alpha_degree = -10;                // corresponds to the DIP joint (fingertip). 70
int delta_beta_degree = -10;                // corresponds to the PIP joint. 110
int delta_gamma_degree = -10;               // corresponds to the MCP joint. 120

int alpha_min = -70; 
int alpha_max = 0; 

int beta_min = -110; 
int beta_max = 0; 

int gamma_min = -120; 
int gamma_max = 0; 

// There are two different adresses for the two Adafruit motor boards: pwm & pwm2
Adafruit_PWMServoDriver pwm1 = Adafruit_PWMServoDriver(0x40); // motor board 1 mit Servos von 11 - 35
Adafruit_PWMServoDriver pwm2 = Adafruit_PWMServoDriver(0x41); // motor board 1 mit Servos von 41 - 55

/* 
Assignement of the servo motors (left arm) --> Number Servo motor (corresponding Pin)

pwm1: 11(0), 12(1), 13(2), 14(3)
      21(4), 22(5), 23(6), 24(7)
      31(8), 32(9), 33(10), 34(11)

pwm2: 41(0), 42(1), 43(2), 44(3)
      51(5), 52(6), 53(7), 54(8)
*/

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  Serial.println("movement of the roboy hand");
  pwm1.begin();
  pwm2.begin();

  // Servos run at ~50 Hz updates
  pwm1.setPWMFreq(50);  
  pwm2.setPWMFreq(50); 
  yield();
}

//////////////////////////////////////////////////////////////////
/////////    Calculations for the finger positions         ///////
//////////////////////////////////////////////////////////////////

//int pulselength_alpha = map(alpha_min, 0, 180, SERVOMIN_alpha, SERVOMAX_alpha);
//int pulselength_alpha = map(alpha_min, 0, 180, SERVOMIN_alpha, SERVOMAX_alpha);

//int pulselength_beta = map(delta_beta_degree, 0, 180, SERVOMIN_beta, SERVOMAX_beta);
//double pulselength_gamma = map(delta_gamma_degree, 0, 180, SERVOMIN_gamma, SERVOMAX_gamma);


double delta_x4 = - delta_gamma_degree * r_c_x4 ;
double delta_x3 = (-delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4); 
double delta_x2 = (-delta_alpha_degree * r_a_x2) + (delta_beta_degree * ra_b_x3) + (delta_gamma_degree * r_c_x4);
double delta_x1 = (delta_alpha_degree * r_a_x2) + (delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4);

double calc_current_4(int x_start_4, int delta_x4) {
              double x_current_4 = x_start_4 - delta_x4; 
              return x_current_4;   
}

double calc_current_3(int x_start_3, double delta_x3) {
              double x_current_3 = x_start_3 - delta_x3;
              return x_current_3;    
}

double calc_current_2(int x_start_2, double delta_x3) {
              double x_current_2 = x_start_2 - delta_x2;
              return x_current_2;    
} 

double calc_current_1(int x_start_1, double delta_x1) {
              double x_current_1 = x_start_1 - delta_x1;
              return x_current_1;    
} 

//////////////////////////////////////////////////////////////////
//////////////////    Movement index finger          /////////////
//////////////////    from stretch to flexion        /////////////
//////////////////////////////////////////////////////////////////
// von gestreckten in den gebeugten Zustand

void stretch_flexion_indexfinger(double x_current_4, double x_current_3, double x_current_2, double x_current_1, int alpha_max, int alpha_min, int beta_max, int beta_min, int gamma_max, int gamma_min){
Serial.println("TEST");
    Serial.println("flexion indexfinger: delta_alpha_degree");
    Serial.println(delta_alpha_degree);
    Serial.println("flexion indexfinger: delta_beta_degree");
    Serial.println(delta_beta_degree);
    Serial.println("flexion indexfinger: delta_gamma_degree");
    Serial.println(delta_gamma_degree);


 while ((delta_alpha_degree <= alpha_max && delta_alpha_degree >= alpha_min) || (delta_beta_degree <= beta_max && delta_beta_degree >= beta_min) || (delta_gamma_degree <= gamma_max && delta_gamma_degree >= gamma_min))
   {
    double delta_x4 = - delta_gamma_degree * r_c_x4 ;
    double delta_x3 = (-delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4); 
    double delta_x2 = (-delta_alpha_degree * r_a_x2) + (delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4);
    double delta_x1 = (delta_alpha_degree * r_a_x2) + (delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4);
    
    double x_current_4 = calc_current_4(x_start_4, delta_x4);
    double x_current_3 = calc_current_3(x_start_3, delta_x3);
    double x_current_2 = calc_current_2(x_start_2, delta_x2);
    double x_current_1 = calc_current_1(x_start_1, delta_x1);
    
    pwm2.setPWM(0, 0, x_current_4);              // 41 servo motor / Pin 0 --> stretch MCP
    pwm1.setPWM(4, 0, x_current_3);              // 21 servo motor / Pin 4 --> stretch PIP 
    pwm1.setPWM(1, 0, x_current_2);              // 12 servo motor / Pin 1 --> stretch DIP (fingertip) 
    pwm1.setPWM(9, 0, x_current_1);              // 32 servo motor / Pin 9 --> flexion  
    
    Serial.println("flexion indexfinger: x_current_4");
    Serial.println(x_current_4);
    Serial.println("flexion indexfinger: x_current_3");
    Serial.println(x_current_3);
    Serial.println("flexion indexfinger: x_current_2");
    Serial.println(x_current_2);
    Serial.println("flexion indexfinger: x_current_1");
    Serial.println(x_current_1);

    Serial.println("flexion indexfinger: delta_alpha_degree");
    Serial.println(delta_alpha_degree);
    Serial.println("flexion indexfinger: delta_beta_degree");
    Serial.println(delta_beta_degree);
    Serial.println("flexion indexfinger: delta_gamma_degree");
    Serial.println(delta_gamma_degree);
    delay(500);

    delta_alpha_degree-=SCHRITTWEITE;         // x_current_2
    delta_beta_degree-=SCHRITTWEITE;          // x_current_3
    delta_gamma_degree-=SCHRITTWEITE;         // x_current_4
    if ((delta_alpha_degree >= alpha_max && delta_alpha_degree <= alpha_min) || (delta_beta_degree >= beta_max || delta_beta_degree <= beta_min) || (delta_gamma_degree >= gamma_max || delta_gamma_degree <= gamma_min)){
        break;
        }
    }
}

//////////////////////////////////////////////////////////////////
//////////////////    Movement index finger          /////////////
//////////////////    from flexion to stretch        /////////////
//////////////////////////////////////////////////////////////////
// von gebeugten Zustand in den gestreckten Zustand

void flexion_stretch_indexfinger(double x_current_4, double x_current_3, double x_current_2, double x_current_1, int alpha_max, int alpha_min, int beta_max, int beta_min, int gamma_max, int gamma_min){

 while ((delta_alpha_degree < alpha_max && delta_alpha_degree > alpha_min) || (delta_beta_degree < beta_max && delta_beta_degree > beta_min) || (delta_gamma_degree < gamma_max && delta_gamma_degree > gamma_min))
   {
    double delta_x4 = - delta_gamma_degree * r_c_x4 ;
    double delta_x3 = (-delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4); 
    double delta_x2 = (-delta_alpha_degree * r_a_x2) + (delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4);
    double delta_x1 = (delta_alpha_degree * r_a_x2) + (delta_beta_degree * r_b_x3) + (delta_gamma_degree * r_c_x4);
    
    double x_current_4 = calc_current_4(x_start_4, delta_x4);
    double x_current_3 = calc_current_3(x_start_3, delta_x3);
    double x_current_2 = calc_current_2(x_start_2, delta_x2);
    double x_current_1 = calc_current_1(x_start_1, delta_x1);

    pwm2.setPWM(0, 0, x_current_4);              // 41 servo motor / Pin 0 --> stretch MCP
    pwm1.setPWM(4, 0, x_current_3);              // 21 servo motor / Pin 4 --> stretch PIP 
    pwm1.setPWM(1, 0, x_current_2);              // 12 servo motor / Pin 1 --> stretch DIP (fingertip) 
    pwm1.setPWM(9, 0, x_current_1);              // 32 servo motor / Pin 9 --> flexion  
    
    Serial.println("stretch indexfinger: x_current_4");
    Serial.println(x_current_4);
    Serial.println("stretch indexfinger: x_current_3");
    Serial.println(x_current_3);
    Serial.println("stretch indexfinger: x_current_2");
    Serial.println(x_current_2);
    Serial.println("stretch indexfinger: x_current_1");
    Serial.println(x_current_1);

    Serial.println("stretch indexfinger: delta_alpha_degree");
    Serial.println(delta_alpha_degree);
    Serial.println("stretch indexfinger: delta_beta_degree");
    Serial.println(delta_beta_degree);
    Serial.println("stretch indexfinger: delta_gamma_degree");
    Serial.println(delta_gamma_degree);
   
    delay(500);
    delta_alpha_degree+=SCHRITTWEITE;
    delta_beta_degree+=SCHRITTWEITE;
    delta_gamma_degree+=SCHRITTWEITE;

    if ((delta_alpha_degree == alpha_max || delta_alpha_degree == alpha_min) || (delta_beta_degree == beta_max || delta_beta_degree == beta_min) || (delta_gamma_degree == gamma_max || delta_gamma_degree == gamma_min)){
        break;
        }
    }  
} 


//////////////////////////////////////////////////////////////////
//////////////////    Neutral position of the wrist     //////////
//////////////////    all tendons are streched         ///////////
//////////////////////////////////////////////////////////////////

void neutral_position_wrist(){
// Nullstelle wrist, 270 --> This is the position where the wrist is in a neutral position
    int neutral_position = 270; 
   
    pwm2.setPWM(6, 0, neutral_position);               //53 servo motor / Pin 6
    pwm1.setPWM(8, 0, neutral_position);               //31 servo motor / Pin 8
    pwm2.setPWM(7, 0, neutral_position);               //54 servo motor / Pin 7
    pwm2.setPWM(1, 0, neutral_position);               //42 servo motor / Pin 0
    Serial.println("neutral position");
    Serial.println(neutral_position); 
  
  }

//////////////////////////////////////////////////////////////////
//////////////////    Movement for the wrist     /////////////////
//////////////////    flexion_extension_wrist   //////////////////
//////////////////////////////////////////////////////////////////
// Movement from flexion to extension = 70°

void flexion_extension_wrist(){
  int wrist_fe = wrist_fe_start;
  do
  {
    pwm2.setPWM(6, 0, wrist_fe);         //53 servo motor / Pin 6
    pwm1.setPWM(8, 0, wrist_fe);         //31 servo motor / Pin 8

    // blaue Tendons, for movement radial - ulnar
    pwm2.setPWM(7, 0, 270);              //54 servo motor / Pin 7
    pwm2.setPWM(1, 0, 270);              //42 servo motor / Pin 0

    Serial.println("flexion_extension_wrist: wrist fe");
    Serial.println(wrist_fe);
       wrist_fe-=SCHRITTWEITE;
       delay(10); // servo movement is reduced 
  } while (wrist_fe >= SERVOMIN && wrist_fe<=SERVOMAX);
}


//////////////////////////////////////////////////////////////////
//////////////////    Movement for the wrist     /////////////////
//////////////////    extension_flexion_wrist   //////////////////
//////////////////////////////////////////////////////////////////
// Movement from extension to flexion = 80°

void extension_flexion_wrist(){
   int wrist_ef = wrist_ef_start;
   do 
  {
    pwm2.setPWM(6, 0, wrist_ef);          //53 servo motor / Pin 6
    pwm1.setPWM(8, 0, wrist_ef);          //31 servo motor / Pin 8
    
    // blaue Tendons, for movement radial - ulnar
    pwm2.setPWM(7, 0, 270);               //54 servo motor / Pin 7
    pwm2.setPWM(1, 0, 270);               //42 servo motor / Pin 0
    
    Serial.println("extension_flexion_wrist: wrist ef");
    Serial.println(wrist_ef);
    wrist_ef+=SCHRITTWEITE;
    delay(10); // servo movement is reduced 
  } while (wrist_ef<= SERVOMAX && wrist_ef>= SERVOMIN);  
}

//////////////////////////////////////////////////////////////////
//////////////////    Movement for the wrist     /////////////////
//////////////////    ulnar_radial_wrist         /////////////////
//////////////////////////////////////////////////////////////////
// Movement from radial to ulnar = 20°

void ulnar_radial_wrist(){
  int wrist_ur = wrist_ur_start;          // wrist_ur = 120
  int wrist_ru = wrist_ru_start;          // wrist_ru = 420
  do
  {
    //Servo 54 und Servo 41 haben entgegengesetzte Werte!!!
    pwm2.setPWM(7, 0, wrist_ur);          //54 servo motor / Pin 7
    pwm2.setPWM(1, 0, wrist_ru);          //42 servo motor / Pin 0

    // orange tendons, for movement flexion - extension
    pwm2.setPWM(6, 0, 270);               //53 servo motor / Pin 6 
    pwm1.setPWM(8, 0, 270);               //31 servo motor / Pin 8 

    Serial.println("ulnar_radial_wrist Servo 42");
    Serial.println(wrist_ur);
    Serial.println("ulnar_radial_wrist Servo54");
    Serial.println(wrist_ru);
       wrist_ur-=SCHRITTWEITE;
       wrist_ru+=SCHRITTWEITE;
       delay(10); // servo movement is reduced 
  } while (wrist_ur >= SERVOMIN && wrist_ur<=SERVOMAX && wrist_ru >= SERVOMIN && wrist_ru <= SERVOMAX); 
}

//////////////////////////////////////////////////////////////////
//////////////////    Movement for the wrist     /////////////////
//////////////////    radial_ulnar_wrist        //////////////////
//////////////////////////////////////////////////////////////////
// Movement from radial to ulnar = 30°

void radial_ulnar_wrist(){
     int wrist_ru = wrist_ru_start;       // wrist_ru = 420
     int wrist_ur = wrist_ur_start;       // wrist_ur = 120
   do 
  {
    //Servo 54 und Servo 41 haben entgegengesetzte Werte!!!
    pwm2.setPWM(7, 0, wrist_ru);          //54 servo motor / Pin 7
    pwm2.setPWM(1, 0, wrist_ur);          //42 servo motor / Pin 0
    
    // orange tendons, for movement flexion - extension
    pwm2.setPWM(6, 0, 270);               //53 servo motor / Pin 6 
    pwm1.setPWM(8, 0, 270);               //31 servo motor / Pin 8
 
    Serial.println("radial_ulnar_wrist Servo 42");
    Serial.println(wrist_ur);
    Serial.println("radial_ulnar_wrist Servo 54");
    Serial.println(wrist_ru);
       wrist_ru+=SCHRITTWEITE;
       wrist_ur-=SCHRITTWEITE;
       delay(10); // servo movement is reduced 
  } while (wrist_ru>= SERVOMIN && wrist_ru<=SERVOMAX && wrist_ur >= SERVOMIN && wrist_ur <= SERVOMAX); 
}


//////////////////////////////////////////////////////////////////
//////////////////   void loop        ////////////////////////////
//////////////////   function call    ////////////////////////////
//////////////////////////////////////////////////////////////////

void loop() {


//test for adjust the servo
neutral_position_wrist();   

/*
    pwm1.setPWM(9, 0, 120);              // 32 servo motor / Pin 9 --> flexion
    delay(2000);

    pwm1.setPWM(9, 0, 200);              // 32 servo motor / Pin 9 --> flexion
        delay(2000);
*/

//////////////////////////////////////////////////////////////////
//////////////////   movement fingers      ///////////////////////
//////////////////////////////////////////////////////////////////

neutral_position_wrist();                   // middle position

double _x_current_4 = calc_current_4(x_start_4, delta_x4);
double _x_current_3 = calc_current_3(x_start_3, delta_x3);
double _x_current_2 = calc_current_2(x_start_2, delta_x2);
double _x_current_1 = calc_current_1(x_start_1, delta_x1);


flexion_stretch_indexfinger(_x_current_4, _x_current_3, _x_current_2, _x_current_1, alpha_max, alpha_min, beta_max, beta_min, gamma_max, gamma_min);             // movement from flexion to stretch indexfinger
delay(2000);
stretch_flexion_indexfinger(_x_current_4, _x_current_3, _x_current_2, _x_current_1, alpha_max, alpha_min, beta_max, beta_min, gamma_max, gamma_min);              // movement from stretch to flexion indexfinger
delay(2000);

//////////////////////////////////////////////////////////////////
//////////////////   movement wrist        ///////////////////////
//////////////////////////////////////////////////////////////////
/*
flexion_extension_wrist();               // movement of the wrist from flexion to extension
delay(2000);
neutral_position_wrist();                  // middle position
delay(2000);
extension_flexion_wrist();                 // movement of the wrist from extension to flexion
delay(2000);
neutral_position_wrist();                  // middle position
delay(2000);
radial_ulnar_wrist();                     // movement of the wrist from ulnar to radial
delay(2000);
neutral_position_wrist();                 // middle position
delay(2000);
ulnar_radial_wrist();                     // movement of the wrist from radial to ulnar
delay(2000); 
neutral_position_wrist();                 // middle position
delay(2000);
*/



}

